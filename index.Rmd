---
title: "Tutorial deforistation monitoring Peru"
author: "Rony Nedkov"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  knitrBootstrap::bootstrap_document:
    title: "Tutorial deforistation monitoring Peru"
    theme: cosmo
    menu: FALSE
---

#Tutorial deforistation monitoring Peru

## Introduction
The `bfastSpatial` package provides utilities to performs change detection analysis (see DeVries et al. 2015; Dutrieux et al. 2015; J. Verbesselt et al. 2010; J. Verbesselt, Zeileis, and Herold 2012) on time-series of spatial gridded data, such as time-series of remote sensing images (Landsat, MODIS and the likes). The tools provided by bfastSpatial allows a user to perform all the steps of the change detection workflow, from pre-processing raw surface reflectance Landsat data, inventorying and preparing them for analysis to the production and formatting of change detection results. The present document is an addition to the [bfast spatial tutorial](http://www.loicdutrieux.com/bfastSpatial/#Downloading_Landsat_data_from_Earth_Explorer_espa) in which the package will be used for deforistation monitoring based on Landsat scenes from Peru. 

In this tutorial the following change detection workflow steps will briefly discussed:

1. Downloading remote sensing scenes
2. Pre-processing the scenes
3. Spatial BFASTMonitor

###Setting up the working environment
Start with setting up your working environment. You want to make sure that we maintain a well structured project to prevent the loss or mixing up of data. In the script below we first load the `libraries` that we will be using. If you cannot load any packages then you most probably need to install it. Use `install.packages()` to do so. Installation of the bfastspatial pacakge can be done using the `instal_github()` method.

```{r, eval=FALSE, results='hide'}
# Loading packages
library(raster)
library(devtools)

# install and load bfastspatial from github
install_github('dutri001/bfastSpatial') #requires devtools
library(bfastSpatial)
```
We will set our working directory by specifying a `projectPath` which points to the folder where the project lives. We will create a `path5_row68` folder inside the `data` folder which we will use to save our initial data to. Set your working directory to the projectPath.

```{r, eval=FALSE, results='hide'}
# Set the working directory
projectPath <- "C:/../DeforestationPeru"
inputdata <- "data/path5_row68"
setwd(projectPath)
```

##1. Downloading Landsat data from Earth Explorer/espa
###Retrieving scene ID's
To download data from the [ESPA](https://espa.cr.usgs.gov/login/?next=/) website we first need to create a text file which contains the Landsat scene ID's of our area of interest. The common way to access the Landsat archives and retrieve the list is via the [Earth Explorer platform](http://earthexplorer.usgs.gov). You will need to register for an account.   

After logging in on the Earth Explorer platform you can search the Landsat archive by:

1. Defining the search criteria
2. Choosing data sets
3. Setting additional criteria
4. Exporting results

For this tutorial we will download scenes by specifying path and row numbers under the path/row tab. We want to find all scenes at **path number 5** and **row number 68**. Click the **show** button after entering the desired path and row number. A marker will appear on the map and this will make sure only scenes from that area will be downloaded. Under the results there is a dropdown menu specifying the number of records to be returned. Select **500** to make sure we have enough Landsat scenes.

![define search criteria](figures/step1.PNG)      

The second step is to select the data sets you wish to order under the Data Sets tab. For this tutorial we will use **Landsat Surface Reflectance - L8 OLI/TIRS** and **Landsat Surface Reflectance - L7 ETM+** from the **Landsat Archive**.

![define search criteria](figures/step2.PNG)

In step three you can select additional criteria depending on your needs. The criterion we are interested in, is the cloud cover. Setting this to **less than 80%** will filter out imagery that are completely covered by clouds and therefore unusable. 

The final step is to export your results. In the results tab you can see a list of the scenes that have been found in the archive according to your search criteria. The scenes can be downloaded by clicking on export results. A new window will open where we can choose our desired output. Choose **CSV**. Repeat this step, but now for the scenes from the other satellite. You can choose the other satellite by clicking on the drop down menu under data sets.

![Choosing other dataset](figures/step3.PNG)


You will receive an email with a link where you can download the requested csv. Save the link in your data folder.

###Placing order at ESPA
ESPA requires a list of scene ID's(e.g. LT52302701999134) in a text file as input. We will create this list with an R script that automatically reads the csv files, retrieves the ID's and saves them to a text file. 

First we want to read both csv in R and retrieve the scene ID's. Also, create a file in which the ID's can be stored. Read the scene ID's of the first file and put them in a variable `sceneID` for further processing. 

```{r, eval=FALSE, results='hide'}
# Read both csv files
csv1 <- read.csv(file = "data/Orderlist/path5_row68/LSR_LANDSAT_8_98327.csv")
csv2 <- read.csv(file = "data/Orderlist/path5_row68/LSR_LANDSAT_ETM_COMBINED_98328.csv")

# Create a text file
order_list <- file("output/orderlist.txt", "w")

# Retrieve scene ID's from first csv file
sceneID <- as.character(csv1$Landsat.Scene.Identifier)
```


Remember to change the `file` argument of `read.csv()` with the `"path/filename.csv"` pointing to the location of the csv on your own computer. The same goes for the output destination of `file()`.

To save each scene ID on a separate line in the text file, we will use a loop that retrieves the scene ID's and adds them one by one to the text file with `writeLines()`.


```{r, eval=FALSE, results='hide'}
# Write the ID's in the text file line by line
for(i in 1:length(sceneID)) {
  ID <- sceneID[i]
  print(ID)
  writeLines(ID, order_list, sep="\n")
}
```
The `sep="\n"` argument creates a new line after adding the ID to the text file. 

We also want to add the scene ID's from the second file. Put the scene ID's from the second file in the `sceneID` variable and run the for loop again. Add the end close the connection to the file. This will save the ID's to the text file. 

```{r, eval=FALSE, results='hide'}
# Retrieve scene ID's from second csv file
sceneID <- as.character(csv2$Landsat.Scene.Identifier)

# Write the ID's in the text file line by line
for(i in 1:length(sceneID)) { 
  ID <- sceneID[i]
  print(ID)
  writeLines(ID, order_list, sep="\n")
}  

# close connection to file
close(order_list)
```

You can check the end result  of this script by opening your text file.

The final step requires Logging in to the [ESPA platform](https://espa.cr.usgs.gov/login/?next=/). Go to the order data page. Here you can upload the text file with the list of scenes you want to have pre-processed. Select the following options:

* CFMask (Cloud mask)
* Surface reflectance NDMI
* Geotiff 

Now you can submit your order.

### Downloading your data

You will receive an email when your order is ready for download. Use a download manager (e.g. Bulk Download Application or DownloadThemAll plugin for Firefox) to download all .tar.gz files and save them in a new subfolder in the `data` folder and name it `path5_row68`. 

##2. Pre-processing the Peru scenes

Let's first create a temporary directory which we will use to save intermediate results of the pre-processing.

```{r}{r, eval=FALSE, results='hide'}
# Create a temporary directory to store the output files.
srdir <- dirout <- file.path(dirname(rasterTmpFile()), 'bfmspatial')
dir.create(dirout, showWarning=FALSE)
```

### Running processLandsatBatch

Now we can use the `processLandsatBatch` method to extract the data and apply the cloud mask which is supplied with the data. We will also provide a new extent to the method to crop all Landsat scenes, since we are only interested in a small part of the entire scene. Specify the extent `c(580485, 617265, -1251615, -1204275))` as a new variable and pass this to the `processLandsatBatch` method.   

```{r, eval=FALSE, results='hide'}
# Create an extent variable
newExtent <- extent(c(580485, 617265, -1251615, -1204275))

# List the Landsat scenes
inputList <- list.files(inputdata, full.names=TRUE)

# Process new landsat scenes
processLandsatBatch(x = inputList, pattern = glob2rx('*.tar.gz'), outdir = dirout, srdir = srdirNDMI, delete = TRUE, vi = 'ndmi', mask = 'cfmask', keep = 0, e = newExtent, overwrite = TRUE)

# List the processed NDMI scenes for stacking
nmdiList <- list.files(dirout, pattern=glob2rx('ndmi*.grd'), full.names = TRUE)
```

This can take some time depending on the size of the dataset. When the process has finished we can list the processed NDMI scenes for further processing.

### Create a multi-temporal raster object

Finally we need to create a mutli-temporal raster object by adding all processed rasters to a `rasterbrick` using the `timeStack` method. First we will create a new directory where we can save the stack. Then we can load the list with the masked Landsat scenes which we will use as the input for the `timeStack`.

```{r, eval=FALSE, results='hide'}
# Create a new subdirectory in the temporary directory
dirout <- file.path(dirname(rasterTmpFile()), 'stack')
dir.create(dirout, showWarnings=FALSE)

# Generate a file name for the output stack
stackName <- file.path(outputdata, 'stackNDMI.grd')

# Stack the layers
ndmiStack <- timeStack(x=ndmiList, filename=stackName, datatype='INT2S', overwrite=TRUE)
```


##3. Spatial BFASTMonitor

###Working with pixels

Use `bfmPixel` to explore the behavior of the Peru datasets. Make sure you have loaded your rasterstack created in the previous section. Plot one scene from the brick, run the `bfmPixel` method and select a pixel you want to explore by clicking on the plotted Landsat scene. 

```{r, eval=FALSE, results='hide'}
#Plot the second scene from the brick
plot(s, 2)

# run bfmPixel() in interactive mode with a monitoring period 
# starting @ the 1st day in 2015
bfm <- bfmPixel(s, start=c(2015, 1), interactive=TRUE)

#Click on a pixel in the plot. 

#Error: Error in xj[i, , drop = FALSE] : subscript out of bounds
```
